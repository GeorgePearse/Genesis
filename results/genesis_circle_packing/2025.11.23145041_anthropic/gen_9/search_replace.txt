```python
# EVOLVE-BLOCK-START
"""Adaptive circle packing for n=26 circles"""

import numpy as np

def construct_packing():
    """
    Construct an adaptive arrangement of 26 circles in a unit square
    that attempts to maximize the sum of their radii.

    Returns:
        Tuple of (centers, radii, sum_of_radii)
        centers: np.array of shape (26, 2) with (x, y) coordinates
        radii: np.array of shape (26) with radius of each circle
        sum_of_radii: Sum of all radii
    """
    n = 26
    centers = np.zeros((n, 2))
    radii = np.zeros(n)

    # Initial placement of circles
    centers[0] = [0.5, 0.5]  # Center circle
    radii[0] = 0.1  # Initial radius

    # Place circles in a structured pattern with variable distances
    for i in range(1, n):
        angle = 2 * np.pi * (i - 1) / (n - 1)
        distance = 0.4 + 0.1 * (i % 2) + 0.05 * (i // 8)  # Vary distance based on circle index
        centers[i] = [0.5 + distance * np.cos(angle), 0.5 + distance * np.sin(angle)]
        radii[i] = 0.1  # Initial radius for outer circles

    # Optimize positions and radii using a more aggressive learning rate
    optimize_packing(centers, radii)

    return centers, radii

def optimize_packing(centers, radii):
    """
    Optimize the positions and radii of the circles to maximize the sum of their radii.

    Args:
        centers: np.array of shape (n, 2) with (x, y) coordinates
        radii: np.array of shape (n) with radius of each circle
    """
    n = centers.shape[0]
    learning_rate = 0.05  # Increased learning rate for faster convergence
    iterations = 2000

    for _ in range(iterations):
        for i in range(n):
            # Calculate gradients for position adjustments
            grad_x, grad_y = 0.0, 0.0
            for j in range(n):
                if i != j:
                    dist = np.linalg.norm(centers[i] - centers[j])
                    if dist < radii[i] + radii[j]:  # Overlap detected
                        overlap = (radii[i] + radii[j]) - dist
                        direction = (centers[i] - centers[j]) / dist
                        grad_x += direction[0] * overlap
                        grad_y += direction[1] * overlap

            # Update positions
            centers[i][0] += learning_rate * grad_x
            centers[i][1] += learning_rate * grad_y

            # Ensure circles stay within the unit square
            centers[i] = np.clip(centers[i], radii[i], 1 - radii[i])

        # Update radii based on new positions
        radii[:] = compute_max_radii(centers)

def compute_max_radii(centers):
    """
    Compute the maximum possible radii for each circle position
    such that they don't overlap and stay within the unit square.

    Args:
        centers: np.array of shape (n, 2) with (x, y) coordinates

    Returns:
        np.array of shape (n) with radius of each circle
    """
    n = centers.shape[0]
    radii = np.ones(n)

    # Limit by distance to square borders
    for i in range(n):
        x, y = centers[i]
        radii[i] = min(x, y, 1 - x, 1 - y)

    # Limit by distance to other circles
    for i in range(n):
        for j in range(i + 1, n):
            dist = np.linalg.norm(centers[i] - centers[j])
            if radii[i] + radii[j] > dist:
                scale = dist / (radii[i] + radii[j])
                radii[i] *= scale
                radii[j] *= scale

    return radii

# EVOLVE-BLOCK-END


# This part remains fixed (not evolved)
def run_packing():
    """Run the circle packing constructor for n=26"""
    centers, radii = construct_packing()
    # Calculate the sum of radii
    sum_radii = np.sum(radii)
    return centers, radii, sum_radii
```

```python
<NAME>
increase_learning_rate_and_variable_distance
</NAME>

<DESCRIPTION>
In the `construct_packing` function, I modified the distance calculation for the outer circles to include an additional term that increases the distance based on the circle index. This will allow for better spacing of circles. Additionally, I increased the learning rate in the `optimize_packing` function to 0.05 for faster convergence during optimization, which may help reach a better packing configuration more quickly.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
        distance = 0.4 + 0.1 * (i % 2)  # Vary distance for outer circles
=======
        distance = 0.4 + 0.1 * (i % 2) + 0.05 * (i // 8)  # Vary distance based on circle index
>>>>>>> REPLACE
<<<<<<< SEARCH
    learning_rate = 0.01
=======
    learning_rate = 0.05  # Increased learning rate for faster convergence
>>>>>>> REPLACE
</DIFF>
```