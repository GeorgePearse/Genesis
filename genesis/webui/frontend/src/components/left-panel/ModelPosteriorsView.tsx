import { useEffect, useRef, useMemo } from 'react';
import * as d3 from 'd3';
import { useGenesis } from '../../context/GenesisContext';
import type { Program } from '../../types';
import './ModelPosteriorsView.css';

export default function ModelPosteriorsView() {
  const { state } = useGenesis();
  const { programs } = state;
  const posteriorsRef = useRef<HTMLDivElement>(null);
  const countsRef = useRef<HTMLDivElement>(null);

  // Extract data logic
  const data = useMemo(() => {
    // Find programs with posteriors
    const programsWithPosteriors = programs.filter(d => {
        const llmResult = d.metadata?.llm_result;
        const modelPosteriors = d.metadata?.model_posteriors;
        
        const hasLlmResultPosteriors = llmResult && 
            typeof llmResult === 'object' && 
            'model_posteriors' in llmResult &&
            typeof (llmResult as any).model_posteriors === 'object';
            
        const hasDirectPosteriors = modelPosteriors && typeof modelPosteriors === 'object';
        
        return hasLlmResultPosteriors || hasDirectPosteriors;
    });

    if (programsWithPosteriors.length === 0) return null;

    const getPosteriors = (p: Program) => {
        const llmResult = p.metadata?.llm_result as any;
        if (llmResult?.model_posteriors) {
            return llmResult.model_posteriors as Record<string, number>;
        }
        if (p.metadata?.model_posteriors) {
            return p.metadata.model_posteriors as Record<string, number>;
        }
        return {};
    };

    const allModels = new Set<string>();
    programsWithPosteriors.forEach(p => {
        Object.keys(getPosteriors(p)).forEach(m => allModels.add(m));
    });
    const models = Array.from(allModels).sort();

    const generationData: Record<number, typeof programs> = {};
    programsWithPosteriors.forEach(p => {
        if (!generationData[p.generation]) generationData[p.generation] = [];
        generationData[p.generation].push(p);
    });

    const generations = Object.keys(generationData).map(Number).sort((a, b) => a - b);

    const chartData: any[] = [];
    generations.forEach(gen => {
        const genPrograms = generationData[gen];
        models.forEach(model => {
            const programsWithThisModel = genPrograms.filter(p => {
                const posteriors = getPosteriors(p);
                return posteriors[model] !== undefined;
            });
            const modelPosteriors = programsWithThisModel.map(p => getPosteriors(p)[model]);
            
            if (modelPosteriors.length > 0) {
                const avgPosterior = modelPosteriors.reduce((a, b) => a + b, 0) / modelPosteriors.length;
                
                // Count programs generated by this model
                const count = genPrograms.filter(p => {
                    const modelName = p.metadata.model || (p.metadata as any).model_name || p.metadata.llm_result?.model;
                    return modelName === model;
                }).length;

                chartData.push({
                    generation: gen,
                    model,
                    posterior: avgPosterior,
                    count
                });
            }
        });
    });

    return { models, generations, chartData, programsWithPosteriors };
  }, [programs]);

  useEffect(() => {
    if (!data || !posteriorsRef.current || !countsRef.current) return;

    const { models, generations, chartData } = data;
    
    // Clear
    d3.select(posteriorsRef.current).selectAll('*').remove();
    d3.select(countsRef.current).selectAll('*').remove();

    const margin = { top: 20, right: 80, bottom: 50, left: 50 };
    const width = posteriorsRef.current.clientWidth - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(models);

    // --- Posteriors Chart ---
    const svgPost = d3.select(posteriorsRef.current)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    const xPost = d3.scaleLinear()
        .domain(d3.extent(generations) as [number, number])
        .range([0, width]);

    const yPost = d3.scaleLinear()
        .domain([0, 1])
        .range([height, 0]);

    svgPost.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(xPost).tickFormat(d3.format('d')));

    svgPost.append('g').call(d3.axisLeft(yPost));

    // Lines
    const line = d3.line<any>()
        .x(d => xPost(d.generation))
        .y(d => yPost(d.posterior))
        .curve(d3.curveMonotoneX);

    models.forEach(model => {
        const modelData = chartData.filter(d => d.model === model).sort((a, b) => a.generation - b.generation);
        if (modelData.length > 0) {
            svgPost.append('path')
                .datum(modelData)
                .attr('fill', 'none')
                .attr('stroke', colorScale(model))
                .attr('stroke-width', 2)
                .attr('d', line);
            
            // Dots
            svgPost.selectAll(`.dot-${model.replace(/[^a-zA-Z0-9]/g, '')}`)
                .data(modelData)
                .enter().append('circle')
                .attr('cx', d => xPost(d.generation))
                .attr('cy', d => yPost(d.posterior))
                .attr('r', 4)
                .attr('fill', colorScale(model))
                .append('title').text(d => `${model}: ${(d.posterior * 100).toFixed(1)}%`);
        }
    });

    // Legend
    const legend = svgPost.append('g')
        .attr('transform', `translate(${width + 10}, 0)`);
    
    models.forEach((model, i) => {
        const g = legend.append('g').attr('transform', `translate(0, ${i * 20})`);
        g.append('rect').attr('width', 10).attr('height', 10).attr('fill', colorScale(model));
        g.append('text').attr('x', 15).attr('y', 10).text(model).style('font-size', '10px').attr('alignment-baseline', 'middle');
    });

    // --- Counts Chart ---
    const svgCounts = d3.select(countsRef.current)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Calculate cumulative counts
    const cumulativeData: Record<string, any[]> = {};
    models.forEach(model => {
        cumulativeData[model] = [];
        let sum = 0;
        generations.forEach(gen => {
            const point = chartData.find(d => d.generation === gen && d.model === model);
            const count = point ? point.count : 0;
            sum += count;
            cumulativeData[model].push({ generation: gen, count: sum });
        });
    });

    const maxCount = Math.max(...Object.values(cumulativeData).flat().map(d => d.count));

    const yCounts = d3.scaleLinear()
        .domain([0, maxCount])
        .range([height, 0]);

    svgCounts.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(xPost).tickFormat(d3.format('d')));

    svgCounts.append('g').call(d3.axisLeft(yCounts));

    const lineCount = d3.line<any>()
        .x(d => xPost(d.generation))
        .y(d => yCounts(d.count));

    models.forEach(model => {
        const modelData = cumulativeData[model];
        svgCounts.append('path')
            .datum(modelData)
            .attr('fill', 'none')
            .attr('stroke', colorScale(model))
            .attr('stroke-width', 2)
            .attr('d', lineCount);
    });

    // Legend for counts
    const legendCounts = svgCounts.append('g')
        .attr('transform', `translate(${width + 10}, 0)`);
    
    models.forEach((model, i) => {
        const g = legendCounts.append('g').attr('transform', `translate(0, ${i * 20})`);
        g.append('rect').attr('width', 10).attr('height', 10).attr('fill', colorScale(model));
        g.append('text').attr('x', 15).attr('y', 10).text(model).style('font-size', '10px').attr('alignment-baseline', 'middle');
    });

  }, [data]);

  if (!data) {
    return (
      <div className="model-posteriors-view empty">
        <p>No model posterior data available for this evolution run.</p>
      </div>
    );
  }

  return (
    <div className="model-posteriors-view">
      <h4>Model Posteriors Over Generations</h4>
      
      <h5>Cumulative Programs by Model</h5>
      <div ref={countsRef} className="chart-container"></div>

      <h5>Average Model Posterior</h5>
      <div ref={posteriorsRef} className="chart-container"></div>

      <div className="model-stats">
        <h5>Model Usage Summary</h5>
        <table className="stats-table">
          <thead>
            <tr>
              <th>Model</th>
              <th>Total</th>
              <th>Correct</th>
              <th>Success Rate</th>
            </tr>
          </thead>
          <tbody>
            {data.models.map((model) => {
                const modelPrograms = programs.filter(p => (p.metadata.model || (p.metadata as any).model_name || p.metadata.llm_result?.model) === model);
                const correct = modelPrograms.filter(p => p.correct).length;
                const total = modelPrograms.length;
                return (
                  <tr key={model}>
                    <td>{model}</td>
                    <td>{total}</td>
                    <td>{correct}</td>
                    <td>{total > 0 ? ((correct / total) * 100).toFixed(1) : 0}%</td>
                  </tr>
                );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
}
